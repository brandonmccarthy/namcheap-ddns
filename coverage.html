
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">namecheap-ddns/ddns.go (48.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        namecheap "github.com/billputer/go-namecheap"
        "github.com/cenkalti/backoff"
        "github.com/golang/glog"
        "io/ioutil"
        "net"
        "net/http"
        "regexp"
        "strings"
        "time"
)

var IP_REGEX = regexp.MustCompile(`[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`)

type fqdn struct {
        TLD, SLD, Subdomain string
}

// dnsClient interface for mock testing
type dnsClient interface {
        DomainDNSSetHosts(sld, tld string, hosts []namecheap.DomainDNSHost) (*namecheap.DomainDNSSetHostsResult, error)
}

// updateDomain uses the namecheap API to set the record of a host
func updateDomain(client dnsClient, f, ip string) error <span class="cov8" title="1">{
        domain, err := parseFQDN(f)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to parse FQDN: %v", err)
        }</span>

        <span class="cov8" title="1">var req []namecheap.DomainDNSHost
        req = append(req, namecheap.DomainDNSHost{
                Name:    domain.Subdomain,
                Type:    "A",
                Address: ip,
        },
        )

        res, err := client.DomainDNSSetHosts(domain.SLD, domain.TLD, req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to set host address: %v", err)
        }</span>
        <span class="cov8" title="1">if !res.IsSuccess </span><span class="cov0" title="0">{
                return fmt.Errorf("dns change request unsuccessful")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Reverse slice of string
func reverse(s []string) []string <span class="cov8" title="1">{
        var result []string
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                result = append(result, s[i])
        }</span>
        <span class="cov8" title="1">return result</span>
}

// parseFQDN takes a string and returns fqdn struct
func parseFQDN(f string) (*fqdn, error) <span class="cov8" title="1">{
        fs := strings.Split(f, ".")
        fs = reverse(fs)
        if len(fs) &lt; 3 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("FQDN must have TLD, SLD, and subdomain")
        }</span>
        <span class="cov8" title="1">return &amp;fqdn{
                TLD:       fs[0],
                SLD:       fs[1],
                Subdomain: fs[2],
        }, nil</span>
}

// getLocalIP uses an external website to determine local public IP address and
// return the net.IP type address
func getLocalIP(ipResolver string) (net.IP, error) <span class="cov8" title="1">{
        var resp *http.Response
        operation := func() error </span><span class="cov8" title="1">{
                r, err := http.Get(ipResolver)
                if err != nil </span><span class="cov8" title="1">{
                        return &amp;backoff.PermanentError{Err: fmt.Errorf("error accessing URL %s: %v\n", ipResolver, err)}
                }</span>
                <span class="cov8" title="1">if r.StatusCode != 200 </span><span class="cov0" title="0">{
                        glog.Infof("Domain %s responded with status code %d, retrying...", ipResolver, r.StatusCode)
                        return fmt.Errorf("server returned error code %d\n", resp.StatusCode)
                }</span>
                <span class="cov8" title="1">resp = r
                return nil</span>
        }

        <span class="cov8" title="1">err := backoff.Retry(operation, backoff.NewExponentialBackOff())
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unable to get response from server: %v\n", err)
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()
        bodyResp, err := ioutil.ReadAll(resp.Body)
        body := string(bodyResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading body response: %v\n", err)
        }</span>

        <span class="cov8" title="1">match := IP_REGEX.FindString(body)
        if match == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("regex couldn't find IP address in website response\n")
        }</span>

        <span class="cov8" title="1">ipAddr := net.ParseIP(match)
        if ipAddr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse IP address from regex match\n")
        }</span>
        <span class="cov8" title="1">return ipAddr, nil</span>
}

func main() <span class="cov0" title="0">{
        // What is the difference between user and username?
        var (
                domainList  = flag.String("domains", "", "The domains we want to check against.")
                ipResolver  = flag.String("resolver", "http://canhazip.com", "The full URL for the domain to resolve local IP against.")
                apiUser     = flag.String("user", "", "Username to use for the namecheap API.")
                apiToken    = flag.String("token", "", "Token for the namecheap API.")
                apiUsername = flag.String("username", "", "Name to use for the namecheap API.")
                tts         = flag.Duration("sleep", 30*time.Minute, "Duration to sleep between checking localIP and domains.")
        )

        flag.Parse()
        var domains []string

        // Variable checking to make sure we have values
        if *domainList == "" </span><span class="cov0" title="0">{
                glog.Exitf("No domains given, exiting.")
        }</span><span class="cov0" title="0"> else {
                domains = strings.Split(*domainList, ",")
        }</span>
        <span class="cov0" title="0">if *apiUser == "" </span><span class="cov0" title="0">{
                glog.Exitf("No user for namecheap API specified, exiting.")
        }</span>
        <span class="cov0" title="0">if *apiToken == "" </span><span class="cov0" title="0">{
                glog.Exitf("No token for namecheap API specified, exiting.")
        }</span>
        <span class="cov0" title="0">if *apiUsername == "" </span><span class="cov0" title="0">{
                glog.Exitf("No username for namecheap API specified, exiting.")
        }</span>

        <span class="cov0" title="0">client := namecheap.NewClient(*apiUser, *apiToken, *apiUsername)
        if client == nil </span><span class="cov0" title="0">{
                glog.Exitf("Unable to create new namecheap client.")
        }</span>

        // Run until interrupted
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Get the local IP address and error if not
                glog.Info("Getting local IP address")
                localIP, err := getLocalIP(*ipResolver)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Unable to get local IP address: %v\n", err)
                }</span>
                <span class="cov0" title="0">glog.Infof("Local IP address is %s\n", localIP.String())

                // Iterate through domains and check IP addresses and update if needed
                for _, domain := range domains </span><span class="cov0" title="0">{
                        // Lookup the ip addresses of a domain and return list of IP addresses
                        domainIPs, err := net.LookupIP(domain)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Warningf("Could not get IP addresses for domain %s: %v\n", domain, err)
                        }</span>
                        <span class="cov0" title="0">domainIP := domainIPs[0] // I only have one IP address per sub-domain
                        if domainIP.String() != localIP.String() </span><span class="cov0" title="0">{
                                glog.Warningf("Domain %s has IP %s want %s\n", domain, domainIP.String(), localIP.String())
                                err := updateDomain(client, domain, localIP.String())
                                if err != nil </span><span class="cov0" title="0">{
                                        glog.Warningf("Could not update domain %s: %v", domain, err)
                                }</span>
                        }<span class="cov0" title="0"> else {
                                glog.Infof("Domain %s is good", domain)
                        }</span>
                }

                <span class="cov0" title="0">glog.Infof("Starting to sleep for %v", *tts)
                time.Sleep(*tts)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
